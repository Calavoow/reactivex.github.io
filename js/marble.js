// Generated by CoffeeScript 1.7.1

/*
 * GLOBALS
 */

(function() {
  var Graphics, addEvent, canvas, create_output_stream, currStream, eventRadius, removeEvent, render, stream_to_observable, streams, util;

  canvas = void 0;

  streams = void 0;

  currStream = void 0;

  eventRadius = 20;


  /*
   * MAIN
   */

  window.onload = function() {
    canvas = document.getElementById("rxCanvas");
    streams = [
      {
        shape: "circle",
        y: canvas.height / 8,
        events: [],
        end: 450
      }, {
        shape: "square",
        y: canvas.height / 8 * 3,
        events: [],
        end: 470
      }
    ];
    currStream = streams[0];
    canvas.addEventListener("mousemove", (function(evt) {
      var mousePos;
      mousePos = util.getMousePos(canvas, evt);
      currStream = util.getCurrentStream(mousePos);
      render(canvas, mousePos);
    }), false);
    canvas.addEventListener("mousedown", (function(evt) {
      var mousePos;
      mousePos = util.getMousePos(canvas, evt);
      if (util.diff(mousePos.y, currStream.y) < 2 * eventRadius) {
        if (util.isOnEvent(mousePos)) {
          removeEvent(mousePos);
        } else {
          addEvent(mousePos);
        }
        render(canvas, mousePos);
      }
    }), false);
    canvas.addEventListener("mouseout", (function(evt) {
      var mousePos;
      mousePos = {
        x: -1337,
        y: -1337
      };
      render(canvas, mousePos);
    }), false);
    render(canvas, util.getMousePos(canvas, null));
  };


  /*
   * LOGIC
   */

  create_output_stream = function() {
    var output_stream, scheduler, xs, ys;
    scheduler = new Rx.TestScheduler();
    xs = stream_to_observable(streams[0], scheduler);
    ys = stream_to_observable(streams[1], scheduler);
    output_stream = {
      shape: "unknown",
      y: util.output_stream_y(),
      events: [],
      end: 0
    };
    xs.merge(ys).subscribe((function(evt) {
      output_stream.events.push(evt);
    }), (function(err) {}), function() {
      output_stream.end = scheduler.now();
    });
    scheduler.start();
    return output_stream;
  };

  stream_to_observable = function(stream, scheduler) {
    var events, evt, i, onCompleted, onNext;
    onNext = Rx.ReactiveTest.onNext;
    onCompleted = Rx.ReactiveTest.onCompleted;
    events = [];
    i = 0;
    while (i < stream.events.length) {
      evt = stream.events[i];
      if ((evt != null) && evt !== undefined) {
        events.push(onNext(evt.x, evt));
      }
      i++;
    }
    events.push(onCompleted(stream.end));
    return scheduler.createColdObservable(events);
  };

  render = function(canvas, mousePos) {
    var ctx, gfx, i;
    ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    gfx = new Graphics(ctx);
    for (i in streams) {
      gfx.draw_stream(streams[i], false);
    }
    util.set_pointer(mousePos);
    gfx.draw_cursor(mousePos);
    gfx.draw_operator(canvas);
    gfx.draw_stream(create_output_stream(), true);
  };

  addEvent = function(mousePos) {
    if (mousePos.x + eventRadius < currStream.end) {
      currStream.events.push({
        x: mousePos.x,
        color: util.random_color(),
        shape: currStream.shape
      });
    }
  };

  removeEvent = function(mousePos) {
    var evt, i;
    for (i in currStream.events) {
      evt = currStream.events[i];
      if (util.diff(evt.x, mousePos.x) < 2 * eventRadius) {
        delete currStream.events[i];
      }
    }
  };


  /*
   * GRAPHICS
   */

  Graphics = (function() {
    function Graphics(ctx) {
      this.ctx = ctx;
    }

    Graphics.prototype.draw_stream = function(stream, isOutput) {
      var evt, i, op_y;
      op_y = util.operator_y();
      this.draw_arrow(10, canvas.width - 10, stream.y);
      for (i in stream.events) {
        evt = stream.events[i];
        switch (evt.shape) {
          case "circle":
            this.fill_circle(evt.x, stream.y, evt.color, false);
            break;
          case "square":
            this.fill_square(evt.x, stream.y, evt.color, false);
        }
        if (isOutput) {
          this.draw_dashed_arrow(evt.x, op_y + 2.5 * eventRadius, stream.y - eventRadius);
        } else {
          this.draw_dashed_arrow(evt.x, stream.y + eventRadius, op_y);
        }
      }
      this.draw_line(stream.end, stream.y - eventRadius, stream.end, stream.y + eventRadius, "#000000");
    };

    Graphics.prototype.draw_cursor = function(mousePos) {
      var isMarked;
      if (util.is_on_stream(mousePos)) {
        isMarked = util.isOnEvent(mousePos);
        switch (currStream.shape) {
          case "circle":
            return this.draw_circle(mousePos.x, currStream.y, "red", isMarked);
          case "square":
            return this.draw_square(mousePos.x, currStream.y, "red", isMarked);
        }
      }
    };

    Graphics.prototype.draw_operator = function() {
      var y;
      y = util.operator_y();
      this.ctx.beginPath();
      this.ctx.rect(10, y, canvas.width - 20, 2.5 * eventRadius);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.stroke();
    };


    /*
    	 * GRAPHICAL PRIMITIVES
     */

    Graphics.prototype.draw_line = function(fromx, fromy, tox, toy, color) {
      this.ctx.beginPath();
      this.ctx.lineWith = 3;
      this.ctx.strokeStyle = color;
      this.ctx.moveTo(fromx, fromy);
      this.ctx.lineTo(tox, toy);
      this.ctx.stroke();
    };

    Graphics.prototype.draw_arrow = function(fromx, tox, y) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.moveTo(fromx, y);
      this.ctx.lineTo(tox - eventRadius, y);
      this.ctx.moveTo(tox - eventRadius, y - 0.5 * eventRadius);
      this.ctx.lineTo(tox, y);
      this.ctx.lineTo(tox - eventRadius, y + 0.5 * eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_dashed_arrow = function(x, fromy, toy) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.setLineDash([4, 7]);
      this.ctx.moveTo(x, fromy);
      this.ctx.lineTo(x, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.setLineDash([]);
      this.ctx.moveTo(x - 0.5 * eventRadius, toy - eventRadius);
      this.ctx.lineTo(x, toy);
      this.ctx.lineTo(x + 0.5 * eventRadius, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.stroke();
      });
    };

    Graphics.prototype.fill_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.fill();
      });
    };

    Graphics.prototype.circle = function(centerx, centery, color, isMarked, drawFunc) {
      this.ctx.beginPath();
      this.ctx.arc(centerx, centery, eventRadius, 0, 2 * Math.PI, false);
      this.ctx.fillStyle = color;
      drawFunc(this.ctx);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    Graphics.prototype.draw_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, false);
    };

    Graphics.prototype.fill_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, true);
    };

    Graphics.prototype.square = function(centerx, centery, color, isMarked, doFill) {
      this.ctx.beginPath();
      this.ctx.rect(centerx - eventRadius, centery - eventRadius, 2 * eventRadius, 2 * eventRadius);
      if (doFill) {
        this.ctx.fillStyle = color;
        this.ctx.fill();
      }
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    return Graphics;

  })();


  /*
   * UTILITIES
   */

  util = {
    getCurrentStream: function(mousePos) {
      var distance, i, minDistance, selectedStream, stream;
      minDistance = Number.POSITIVE_INFINITY;
      selectedStream = currStream;
      for (i in streams) {
        stream = streams[i];
        distance = this.diff(stream.y, mousePos.y);
        if (distance < minDistance) {
          minDistance = distance;
          selectedStream = stream;
        }
      }
      return selectedStream;
    },
    is_on_stream: function(mousePos) {
      return this.diff(mousePos.y, currStream.y) < 2 * eventRadius;
    },
    diff: function(a, b) {
      return Math.abs(a - b);
    },
    isOnEvent: function(mousePos) {
      var evt, i;
      for (i in currStream.events) {
        evt = currStream.events[i];
        if (this.diff(evt.x, mousePos.x) < 2 * eventRadius) {
          return true;
        }
      }
      return false;
    },
    getMousePos: function(canvas, evt) {
      var rect;
      rect = canvas.getBoundingClientRect();
      if (evt != null) {
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      } else {
        return {
          x: 0,
          y: 0
        };
      }
    },
    set_pointer: function(mousePos) {
      document.body.style.cursor = (this.is_on_stream(mousePos) && this.diff(mousePos.x, currStream.end) < 5 ? "ew-resize" : "auto");
    },
    operator_y: function() {
      var i, sy, y;
      y = 0;
      for (i in streams) {
        sy = streams[i].y;
        if (sy > y) {
          y = sy;
        }
      }
      return y + eventRadius * 3;
    },
    output_stream_y: function() {
      var i, stream, ypos;
      ypos = 0;
      for (i in streams) {
        stream = streams[i];
        if (stream.y > ypos) {
          ypos = stream.y;
        }
      }
      return ypos + eventRadius * 9;
    },
    random_color: function() {
      var color, i, letters;
      letters = "0123456789ABCDEF".split("");
      color = "#";
      i = 0;
      while (i < 6) {
        color += letters[Math.round(Math.random() * 15)];
        i++;
      }
      return color;
    }
  };

}).call(this);
