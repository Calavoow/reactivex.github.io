// Generated by CoffeeScript 1.7.1

/*
 * GLOBALS
 */

(function() {
  var Graphics, addEvent, canvas, cleanNotifications, create_output_stream, currStream, eventRadius, removeNotification, render, setComplete, stream_to_observable, streams, util;

  canvas = void 0;

  streams = void 0;

  currStream = void 0;

  eventRadius = 20;


  /*
   * MAIN
   */

  window.onload = function() {
    canvas = document.getElementById("rxCanvas");
    streams = [
      {
        shape: "circle",
        y: canvas.height / 8,
        notifications: [],
        end: 450,
        start: 10,
        maxEnd: canvas.width - 10
      }, {
        shape: "square",
        y: canvas.height / 8 * 3,
        notifications: [],
        end: 470,
        start: 10,
        maxEnd: canvas.width - 10
      }
    ];
    currStream = streams[0];
    canvas.addEventListener("mousemove", (function(evt) {
      var mousePos;
      mousePos = util.setMousePos(canvas, evt);
      currStream = util.getCurrentStream(mousePos);
      render(canvas, mousePos);
    }), false);
    canvas.addEventListener("mousedown", (function(evt) {
      var mousePos, notifIdx;
      mousePos = util.setMousePos(canvas, evt);
      if (util.diff(mousePos.y, currStream.y) < 2 * eventRadius) {
        notifIdx = util.onNotification(mousePos);
        if (notifIdx != null) {
          removeNotification(notifIdx);
        } else {
          addEvent(mousePos);
        }
        render(canvas, mousePos);
      }
    }), false);
    canvas.addEventListener("mouseout", (function(evt) {
      var mousePos;
      mousePos = {
        x: -1337,
        y: -1337
      };
      render(canvas, mousePos);
    }), false);
    canvas.addEventListener("keypress", (function(evt) {
      var mousePos, notifIdx;
      mousePos = util.getMousePos();
      if (util.diff(mousePos.y, currStream.y) < 2 * eventRadius) {
        notifIdx = util.onNotification(mousePos);
        if (notifIdx != null) {
          console.log("Removin thing");
          removeNotification(notifIdx);
        } else {
          switch (evt.which) {
            case 101:
              console.log("E pressed");
              addError(mousePos);
              break;
            case 99:
              console.log("C pressed");
              setComplete(mousePos);
              break;
            default:
              console.log(evt.which);
          }
        }
      }
    }), false);
    render(canvas, util.getMousePos());
  };


  /*
   * LOGIC
   */

  create_output_stream = function() {
    var output_stream, scheduler, xs, ys;
    scheduler = new Rx.TestScheduler();
    xs = stream_to_observable(streams[0], scheduler);
    ys = stream_to_observable(streams[1], scheduler);
    output_stream = {
      shape: "unknown",
      y: util.output_stream_y(),
      notifications: [],
      start: 10,
      end: 0
    };
    xs.merge(ys).subscribe((function(evt) {
      output_stream.notifications.push(evt);
    }), (function(err) {}), function() {
      output_stream.end = scheduler.now();
      output_stream.maxEnd = output_stream.end + 2 * eventRadius;
    });
    scheduler.start();
    return output_stream;
  };

  stream_to_observable = function(stream, scheduler) {
    var evt, i, notifications, onCompleted, onNext;
    onNext = Rx.ReactiveTest.onNext;
    onCompleted = Rx.ReactiveTest.onCompleted;
    notifications = [];
    i = 0;
    while (i < stream.notifications.length) {
      evt = stream.notifications[i];
      if (evt != null) {
        notifications.push(onNext(evt.x, evt));
      }
      i++;
    }
    notifications.push(onCompleted(stream.end));
    return scheduler.createColdObservable(notifications);
  };

  render = function(canvas, mousePos) {
    var ctx, gfx, i;
    ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    gfx = new Graphics(ctx);
    for (i in streams) {
      gfx.draw_stream(streams[i], false);
    }
    util.set_pointer(mousePos);
    gfx.draw_cursor(mousePos);
    gfx.draw_operator(canvas);
    gfx.draw_stream(create_output_stream(), true);
  };

  addEvent = function(mousePos) {
    if (mousePos.x + eventRadius < currStream.end) {
      currStream.notifications.push({
        x: mousePos.x,
        color: util.random_color(),
        shape: currStream.shape
      });
    }
  };

  setComplete = function(mousePos) {
    if (mousePos.x - eventRadius > currStream.start && mousePos.x + eventRadius < currStream.maxEnd) {
      currStream.end = mousePos.x;
      return cleanNotifications();
    }
  };


  /*
   * Remove notifications that are after the currStream's end
   */

  cleanNotifications = function() {
    var i, notif, _i, _len, _ref;
    _ref = currStream.notifications;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      notif = _ref[i];
      if (notif.x + eventRadius > currStream.end) {
        removeNotification(i);
      }
    }
  };

  removeNotification = function(notifIdx) {
    currStream.notifications.splice(notifIdx, 1);

    /*
    		for i of currStream.notifications
    			evt = currStream.notifications[i]
    			delete currStream.notifications[i]	if util.diff(evt.x, mousePos.x) < 2 * eventRadius
     */
  };


  /*
   * GRAPHICS
   */

  Graphics = (function() {
    function Graphics(ctx) {
      this.ctx = ctx;
    }

    Graphics.prototype.draw_stream = function(stream, isOutput) {
      var i, notif, op_y;
      op_y = util.operator_y();
      this.draw_arrow(stream.start, stream.maxEnd - 10, stream.y);
      for (i in stream.notifications) {
        notif = stream.notifications[i];
        switch (notif.shape) {
          case "circle":
            this.fill_circle(notif.x, stream.y, notif.color, false);
            break;
          case "square":
            this.fill_square(notif.x, stream.y, notif.color, false);
        }
        if (isOutput) {
          this.draw_dashed_arrow(notif.x, op_y + 2.5 * eventRadius, stream.y - eventRadius);
        } else {
          this.draw_dashed_arrow(notif.x, stream.y + eventRadius, op_y);
        }
      }
      this.draw_line(stream.end, stream.y - eventRadius, stream.end, stream.y + eventRadius, "#000000");
    };

    Graphics.prototype.draw_cursor = function(mousePos) {
      var isMarked;
      if (util.is_on_stream(mousePos)) {
        isMarked = util.onNotification(mousePos);
        switch (currStream.shape) {
          case "circle":
            return this.draw_circle(mousePos.x, currStream.y, "red", isMarked != null);
          case "square":
            return this.draw_square(mousePos.x, currStream.y, "red", isMarked != null);
        }
      }
    };

    Graphics.prototype.draw_operator = function() {
      var y;
      y = util.operator_y();
      this.ctx.beginPath();
      this.ctx.rect(10, y, canvas.width - 20, 2.5 * eventRadius);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.stroke();
    };


    /*
    	 * GRAPHICAL PRIMITIVES
     */

    Graphics.prototype.draw_line = function(fromx, fromy, tox, toy, color) {
      this.ctx.beginPath();
      this.ctx.lineWith = 3;
      this.ctx.strokeStyle = color;
      this.ctx.moveTo(fromx, fromy);
      this.ctx.lineTo(tox, toy);
      this.ctx.stroke();
    };

    Graphics.prototype.draw_arrow = function(fromx, tox, y) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.moveTo(fromx, y);
      this.ctx.lineTo(tox - eventRadius, y);
      this.ctx.moveTo(tox - eventRadius, y - 0.5 * eventRadius);
      this.ctx.lineTo(tox, y);
      this.ctx.lineTo(tox - eventRadius, y + 0.5 * eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_dashed_arrow = function(x, fromy, toy) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.setLineDash([4, 7]);
      this.ctx.moveTo(x, fromy);
      this.ctx.lineTo(x, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.setLineDash([]);
      this.ctx.moveTo(x - 0.5 * eventRadius, toy - eventRadius);
      this.ctx.lineTo(x, toy);
      this.ctx.lineTo(x + 0.5 * eventRadius, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.stroke();
      });
    };

    Graphics.prototype.fill_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.fill();
      });
    };

    Graphics.prototype.circle = function(centerx, centery, color, isMarked, drawFunc) {
      this.ctx.beginPath();
      this.ctx.arc(centerx, centery, eventRadius, 0, 2 * Math.PI, false);
      this.ctx.fillStyle = color;
      drawFunc(this.ctx);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    Graphics.prototype.draw_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, false);
    };

    Graphics.prototype.fill_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, true);
    };

    Graphics.prototype.square = function(centerx, centery, color, isMarked, doFill) {
      this.ctx.beginPath();
      this.ctx.rect(centerx - eventRadius, centery - eventRadius, 2 * eventRadius, 2 * eventRadius);
      if (doFill) {
        this.ctx.fillStyle = color;
        this.ctx.fill();
      }
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    return Graphics;

  })();


  /*
   * UTILITIES
   */

  util = {
    getCurrentStream: function(mousePos) {
      var distance, i, minDistance, selectedStream, stream;
      minDistance = Number.POSITIVE_INFINITY;
      selectedStream = currStream;
      for (i in streams) {
        stream = streams[i];
        distance = this.diff(stream.y, mousePos.y);
        if (distance < minDistance) {
          minDistance = distance;
          selectedStream = stream;
        }
      }
      return selectedStream;
    },
    is_on_stream: function(mousePos) {
      return this.diff(mousePos.y, currStream.y) < 2 * eventRadius;
    },
    diff: function(a, b) {
      return Math.abs(a - b);
    },
    onNotification: function(mousePos) {
      var evt, i;
      for (i in currStream.notifications) {
        evt = currStream.notifications[i];
        if (this.diff(evt.x, mousePos.x) < 2 * eventRadius) {
          return i;
        }
      }
      return null;
    },
    pos: {
      x: 0,
      y: 0
    },
    getMousePos: function() {
      return this.pos;
    },
    setMousePos: function(canvas, evt) {
      var rect;
      rect = canvas.getBoundingClientRect();
      this.pos = evt != null ? {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      } : {
        x: 0,
        y: 0
      };
      return this.pos;
    },
    set_pointer: function(mousePos) {
      document.body.style.cursor = (this.is_on_stream(mousePos) && this.diff(mousePos.x, currStream.end) < 5 ? "ew-resize" : "auto");
    },
    operator_y: function() {
      var i, sy, y;
      y = 0;
      for (i in streams) {
        sy = streams[i].y;
        if (sy > y) {
          y = sy;
        }
      }
      return y + eventRadius * 3;
    },
    output_stream_y: function() {
      var i, stream, ypos;
      ypos = 0;
      for (i in streams) {
        stream = streams[i];
        if (stream.y > ypos) {
          ypos = stream.y;
        }
      }
      return ypos + eventRadius * 9;
    },
    random_color: function() {
      var color, i, letters;
      letters = "0123456789ABCDEF".split("");
      color = "#";
      i = 0;
      while (i < 6) {
        color += letters[Math.round(Math.random() * 15)];
        i++;
      }
      return color;
    }
  };

}).call(this);
