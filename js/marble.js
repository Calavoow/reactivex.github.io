// Generated by CoffeeScript 1.7.1

/*
 * GLOBALS
 */

(function() {
  var Graphics, addError, addEvent, canvas, cleanNotifications, create_output_stream, currStream, eventRadius, removeNotification, render, setComplete, stream_to_observable, streams, util, validNotification;

  canvas = void 0;

  streams = void 0;

  currStream = void 0;

  eventRadius = 20;


  /*
   * MAIN
   */

  window.onload = function() {
    canvas = document.getElementById("rxCanvas");
    streams = [
      {
        shape: "circle",
        y: canvas.height / 8,
        notifications: [],
        end: 450,
        start: 10,
        maxEnd: canvas.width - 10
      }, {
        shape: "square",
        y: canvas.height / 8 * 3,
        notifications: [],
        end: 470,
        start: 10,
        maxEnd: canvas.width - 10
      }
    ];
    currStream = streams[0];
    canvas.addEventListener("mousemove", (function(evt) {
      var mousePos;
      mousePos = util.setMousePos(canvas, evt);
      currStream = util.getCurrentStream(mousePos);
      render(canvas, mousePos);
    }), false);
    canvas.addEventListener("mousedown", (function(evt) {
      var mousePos, notifIdx;
      mousePos = util.setMousePos(canvas, evt);
      if (util.diff(mousePos.y, currStream.y) < 2 * eventRadius) {
        notifIdx = util.onNotification(mousePos);
        if (notifIdx != null) {
          removeNotification(notifIdx);
        } else {
          addEvent(mousePos);
        }
        render(canvas, mousePos);
      }
    }), false);
    canvas.addEventListener("mouseout", (function(evt) {
      var mousePos;
      mousePos = {
        x: -1337,
        y: -1337
      };
      render(canvas, mousePos);
    }), false);
    canvas.addEventListener("keypress", (function(evt) {
      var mousePos, notifIdx;
      mousePos = util.getMousePos();
      if (util.diff(mousePos.y, currStream.y) < 2 * eventRadius) {
        notifIdx = util.onNotification(mousePos);
        if (notifIdx != null) {
          console.log("Removin thing");
          removeNotification(notifIdx);
        } else {
          switch (evt.which) {
            case 101:
              console.log("E pressed");
              addError(mousePos);
              break;
            case 99:
              console.log("C pressed");
              setComplete(mousePos);
              break;
            default:
              console.log(evt.which);
          }
        }
      }
      render(canvas, mousePos);
    }), false);
    render(canvas, util.getMousePos());
  };


  /*
   * LOGIC
   */

  create_output_stream = function() {
    var output_stream, scheduler, xs, ys;
    scheduler = new Rx.TestScheduler();
    xs = stream_to_observable(streams[0], scheduler);
    ys = stream_to_observable(streams[1], scheduler);
    output_stream = {
      shape: "unknown",
      y: util.output_stream_y(),
      notifications: [],
      start: 10,
      end: 0
    };
    xs.merge(ys).subscribe((function(evt) {
      output_stream.notifications.push(evt);
    }), (function(err) {
      output_stream.notifications.push(err);
      output_stream.end = null;
      output_stream.maxEnd = err.x + 3 * eventRadius;
    }), function() {
      output_stream.end = scheduler.now();
      output_stream.maxEnd = output_stream.end + 2 * eventRadius;
    });
    scheduler.start();
    return output_stream;
  };

  stream_to_observable = function(stream, scheduler) {
    var notif, notifications, _i, _len, _ref;
    notifications = [];
    _ref = stream.notifications;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      notif = _ref[_i];
      switch (notif.type) {
        case "Event":
          notifications.push(Rx.ReactiveTest.onNext(notif.x, notif));
          break;
        case "Error":
          notifications.push(Rx.ReactiveTest.onError(notif.x, notif));
          break;
        default:
          console.log("Something wrong with notification type");
      }
    }
    if (stream.end != null) {
      notifications.push(Rx.ReactiveTest.onCompleted(stream.end));
    }
    return scheduler.createColdObservable(notifications);
  };

  render = function(canvas, mousePos) {
    var ctx, gfx, i;
    ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    gfx = new Graphics(ctx);
    for (i in streams) {
      gfx.draw_stream(streams[i], false);
    }
    util.set_pointer(mousePos);
    gfx.draw_cursor(mousePos);
    gfx.draw_operator(canvas);
    gfx.draw_stream(create_output_stream(), true);
  };

  addEvent = function(mousePos) {
    if (validNotification(mousePos)) {
      currStream.notifications.push({
        x: mousePos.x,
        color: util.random_color(),
        shape: currStream.shape,
        type: "Event"
      });
    }
  };

  addError = function(mousePos) {
    if (validNotification(mousePos)) {
      currStream.notifications.push({
        x: mousePos.x,
        color: util.random_color(),
        type: "Error"
      });
    }
  };


  /*
   * Invariant property of events and errors.
   * Requires a .x property on the given object.
   */

  validNotification = function(notif) {
    return notif.x + eventRadius < currStream.end && notif.x - eventRadius > currStream.start;
  };

  setComplete = function(mousePos) {
    if (mousePos.x - eventRadius > currStream.start && mousePos.x + eventRadius < currStream.maxEnd) {
      currStream.end = mousePos.x;
      return cleanNotifications();
    }
  };


  /*
   * Remove notifications that are after the currStream's end
   */

  cleanNotifications = function() {
    console.log(currStream.notifications);
    currStream.notifications = currStream.notifications.filter(function(notif) {
      var val;
      val = validNotification(notif);
      console.log(val);
      return val;
    });
  };

  removeNotification = function(notifIdx) {
    console.log(notifIdx);
    currStream.notifications.splice(notifIdx, 1);
  };


  /*
   * GRAPHICS
   */

  Graphics = (function() {
    function Graphics(ctx) {
      this.ctx = ctx;
    }

    Graphics.prototype.draw_stream = function(stream, isOutput) {
      var i, notif, op_y;
      op_y = util.operator_y();
      this.draw_arrow(stream.start, stream.maxEnd - 10, stream.y);
      for (i in stream.notifications) {
        notif = stream.notifications[i];
        switch (notif.type) {
          case "Event":
            this.draw_event(stream, notif);
            break;
          case "Error":
            this.draw_error(stream, notif);
        }
        if (isOutput) {
          this.draw_dashed_arrow(notif.x, op_y + 2.5 * eventRadius, stream.y - eventRadius);
        } else {
          this.draw_dashed_arrow(notif.x, stream.y + eventRadius, op_y);
        }
      }
      if (stream.end != null) {
        this.draw_line(stream.end, stream.y - eventRadius, stream.end, stream.y + eventRadius, "#000000");
      }
    };

    Graphics.prototype.draw_event = function(stream, event) {
      switch (event.shape) {
        case "circle":
          return this.fill_circle(event.x, stream.y, event.color, false);
        case "square":
          return this.fill_square(event.x, stream.y, event.color, false);
      }
    };

    Graphics.prototype.draw_error = function(stream, event) {
      return this.draw_cross(event.x, stream.y, event.color);
    };

    Graphics.prototype.draw_cursor = function(mousePos) {
      var isMarked;
      if (util.is_on_stream(mousePos)) {
        isMarked = util.onNotification(mousePos);
        switch (currStream.shape) {
          case "circle":
            return this.draw_circle(mousePos.x, currStream.y, "red", isMarked != null);
          case "square":
            return this.draw_square(mousePos.x, currStream.y, "red", isMarked != null);
        }
      }
    };

    Graphics.prototype.draw_operator = function() {
      var y;
      y = util.operator_y();
      this.ctx.beginPath();
      this.ctx.rect(10, y, canvas.width - 20, 2.5 * eventRadius);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.stroke();
    };


    /*
    	 * GRAPHICAL PRIMITIVES
     */

    Graphics.prototype.draw_line = function(fromx, fromy, tox, toy, color) {
      this.ctx.beginPath();
      this.ctx.lineWith = 3;
      this.ctx.strokeStyle = color;
      this.ctx.moveTo(fromx, fromy);
      this.ctx.lineTo(tox, toy);
      this.ctx.stroke();
    };

    Graphics.prototype.draw_cross = function(centerx, centery, color) {
      this.draw_line(centerx - eventRadius, centery + eventRadius, centerx + eventRadius, centery - eventRadius, color);
      this.draw_line(centerx - eventRadius, centery - eventRadius, centerx + eventRadius, centery + eventRadius, color);
    };

    Graphics.prototype.draw_arrow = function(fromx, tox, y) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.moveTo(fromx, y);
      this.ctx.lineTo(tox - eventRadius, y);
      this.ctx.moveTo(tox - eventRadius, y - 0.5 * eventRadius);
      this.ctx.lineTo(tox, y);
      this.ctx.lineTo(tox - eventRadius, y + 0.5 * eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_dashed_arrow = function(x, fromy, toy) {
      this.ctx.beginPath();
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = "#000000";
      this.ctx.setLineDash([4, 7]);
      this.ctx.moveTo(x, fromy);
      this.ctx.lineTo(x, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.setLineDash([]);
      this.ctx.moveTo(x - 0.5 * eventRadius, toy - eventRadius);
      this.ctx.lineTo(x, toy);
      this.ctx.lineTo(x + 0.5 * eventRadius, toy - eventRadius);
      this.ctx.closePath();
      this.ctx.stroke();
    };

    Graphics.prototype.draw_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.stroke();
      });
    };

    Graphics.prototype.fill_circle = function(centerx, centery, color, isMarked) {
      this.circle(centerx, centery, color, isMarked, function(ctx) {
        ctx.fill();
      });
    };

    Graphics.prototype.circle = function(centerx, centery, color, isMarked, drawFunc) {
      this.ctx.beginPath();
      this.ctx.arc(centerx, centery, eventRadius, 0, 2 * Math.PI, false);
      this.ctx.fillStyle = color;
      drawFunc(this.ctx);
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    Graphics.prototype.draw_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, false);
    };

    Graphics.prototype.fill_square = function(centerx, centery, color, isMarked) {
      this.square(centerx, centery, color, isMarked, true);
    };

    Graphics.prototype.square = function(centerx, centery, color, isMarked, doFill) {
      this.ctx.beginPath();
      this.ctx.rect(centerx - eventRadius, centery - eventRadius, 2 * eventRadius, 2 * eventRadius);
      if (doFill) {
        this.ctx.fillStyle = color;
        this.ctx.fill();
      }
      this.ctx.lineWidth = 3;
      this.ctx.strokeStyle = (isMarked ? "red" : "#000000");
      this.ctx.stroke();
    };

    return Graphics;

  })();


  /*
   * UTILITIES
   */

  util = {
    getCurrentStream: function(mousePos) {
      var distance, i, minDistance, selectedStream, stream;
      minDistance = Number.POSITIVE_INFINITY;
      selectedStream = currStream;
      for (i in streams) {
        stream = streams[i];
        distance = this.diff(stream.y, mousePos.y);
        if (distance < minDistance) {
          minDistance = distance;
          selectedStream = stream;
        }
      }
      return selectedStream;
    },
    is_on_stream: function(mousePos) {
      return this.diff(mousePos.y, currStream.y) < 2 * eventRadius;
    },
    diff: function(a, b) {
      return Math.abs(a - b);
    },
    onNotification: function(mousePos) {
      var evt, i;
      for (i in currStream.notifications) {
        evt = currStream.notifications[i];
        if (this.diff(evt.x, mousePos.x) < 2 * eventRadius) {
          return i;
        }
      }
      return null;
    },
    pos: {
      x: 0,
      y: 0
    },
    getMousePos: function() {
      return this.pos;
    },
    setMousePos: function(canvas, evt) {
      var rect;
      rect = canvas.getBoundingClientRect();
      this.pos = evt != null ? {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      } : {
        x: 0,
        y: 0
      };
      return this.pos;
    },
    set_pointer: function(mousePos) {
      document.body.style.cursor = (this.is_on_stream(mousePos) && this.diff(mousePos.x, currStream.end) < 5 ? "ew-resize" : "auto");
    },
    operator_y: function() {
      var i, sy, y;
      y = 0;
      for (i in streams) {
        sy = streams[i].y;
        if (sy > y) {
          y = sy;
        }
      }
      return y + eventRadius * 3;
    },
    output_stream_y: function() {
      var i, stream, ypos;
      ypos = 0;
      for (i in streams) {
        stream = streams[i];
        if (stream.y > ypos) {
          ypos = stream.y;
        }
      }
      return ypos + eventRadius * 9;
    },
    random_color: function() {
      var color, i, letters;
      letters = "0123456789ABCDEF".split("");
      color = "#";
      i = 0;
      while (i < 6) {
        color += letters[Math.round(Math.random() * 15)];
        i++;
      }
      return color;
    }
  };

}).call(this);
